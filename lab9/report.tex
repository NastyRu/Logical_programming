\documentclass[a4paper,14pt]{extreport} % формат документа

\usepackage{amsmath}
\usepackage{cmap} % поиск в ПДФ
\usepackage[T2A]{fontenc} % кодировка
\usepackage[utf8]{inputenc} % кодировка исходного текста
\usepackage[english,russian]{babel} % локализация и переносы
\usepackage[left = 2cm, right = 1cm, top = 2cm, bottom = 2 cm]{geometry} % поля
\usepackage{listings}
\usepackage{graphicx} % для вставки рисунков
\usepackage{amsmath}
\usepackage{float}
\usepackage{longtable}
\usepackage{multirow}
\graphicspath{{pictures/}}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}
\newcommand{\anonsection}[1]{\section*{#1}\addcontentsline{toc}{section}{#1}}

\lstset{ %
	language=Prolog,                % Язык программирования 
	numbers=left,                   % С какой стороны нумеровать          
	frame=single,                    % Добавить рамку
	 escapebegin=\begin{russian}\commentfont,
    escapeend=\end{russian},
    literate={Ö}{{\"O}}1
    {Ä}{{\"A}}1
    {Ü}{{\"U}}1
    {ß}{{\ss}}1
    {ü}{{\"u}}1
    {ä}{{\"a}}1
    {ö}{{\"o}}1
    {~}{{\textasciitilde}}1
    {а}{{\selectfont\char224}}1
    {б}{{\selectfont\char225}}1
    {в}{{\selectfont\char226}}1
    {г}{{\selectfont\char227}}1
    {д}{{\selectfont\char228}}1
    {е}{{\selectfont\char229}}1
    {ё}{{\"e}}1
    {ж}{{\selectfont\char230}}1
    {з}{{\selectfont\char231}}1
    {и}{{\selectfont\char232}}1
    {й}{{\selectfont\char233}}1
    {к}{{\selectfont\char234}}1
    {л}{{\selectfont\char235}}1
    {м}{{\selectfont\char236}}1
    {н}{{\selectfont\char237}}1
    {о}{{\selectfont\char238}}1
    {п}{{\selectfont\char239}}1
    {р}{{\selectfont\char240}}1
    {с}{{\selectfont\char241}}1
    {т}{{\selectfont\char242}}1
    {у}{{\selectfont\char243}}1
    {ф}{{\selectfont\char244}}1
    {х}{{\selectfont\char245}}1
    {ц}{{\selectfont\char246}}1
    {ч}{{\selectfont\char247}}1
    {ш}{{\selectfont\char248}}1
    {щ}{{\selectfont\char249}}1
    {ъ}{{\selectfont\char250}}1
    {ы}{{\selectfont\char251}}1
    {ь}{{\selectfont\char252}}1
    {э}{{\selectfont\char253}}1
    {ю}{{\selectfont\char254}}1
    {я}{{\selectfont\char255}}1
    {А}{{\selectfont\char192}}1
    {Б}{{\selectfont\char193}}1
    {В}{{\selectfont\char194}}1
    {Г}{{\selectfont\char195}}1
    {Д}{{\selectfont\char196}}1
    {Е}{{\selectfont\char197}}1
    {Ё}{{\"E}}1
    {Ж}{{\selectfont\char198}}1
    {З}{{\selectfont\char199}}1
    {И}{{\selectfont\char200}}1
    {Й}{{\selectfont\char201}}1
    {К}{{\selectfont\char202}}1
    {Л}{{\selectfont\char203}}1
    {М}{{\selectfont\char204}}1
    {Н}{{\selectfont\char205}}1
    {О}{{\selectfont\char206}}1
    {П}{{\selectfont\char207}}1
    {Р}{{\selectfont\char208}}1
    {С}{{\selectfont\char209}}1
    {Т}{{\selectfont\char210}}1
    {У}{{\selectfont\char211}}1
    {Ф}{{\selectfont\char212}}1
    {Х}{{\selectfont\char213}}1
    {Ц}{{\selectfont\char214}}1
    {Ч}{{\selectfont\char215}}1
    {Ш}{{\selectfont\char216}}1
    {Щ}{{\selectfont\char217}}1
    {Ъ}{{\selectfont\char218}}1
    {Ы}{{\selectfont\car219}}1
    {Ь}{{\selectfont\char220}}1
    {Э}{{\selectfont\char221}}1
    {Ю}{{\selectfont\char222}}1
    {Я}{{\selectfont\char223}}1
    {і}{{\selectfont\char105}}1
    {ї}{{\selectfont\char168}}1
    {є}{{\selectfont\char185}}1
    {ґ}{{\selectfont\char160}}1
    {І}{{\selectfont\char73}}1
    {Ї}{{\selectfont\char136}}1
    {Є}{{\selectfont\char153}}1
    {Ґ}{{\selectfont\char128}}1
}

\begin{document}
\begin{titlepage}

    \begin{table}[H]
        \centering
        \footnotesize
        \begin{tabular}{cc}
            \multirow{8}{*}{\includegraphics[scale=0.35]{bmstu.jpg}}
            & \\
            & \\
            & \textbf{Министерство науки и высшего образования Российской Федерации} \\
            & \textbf{Федеральное государственное бюджетное образовательное учреждение} \\
            & \textbf{высшего образования} \\
            & \textbf{<<Московский государственный технический} \\
            & \textbf{университет имени Н.Э. Баумана>>} \\
            & \textbf{(МГТУ им. Н.Э. Баумана)} \\
        \end{tabular}
    \end{table}

    \vspace{-2.5cm}

    \begin{flushleft}
        \rule[-1cm]{\textwidth}{3pt}
        \rule{\textwidth}{1pt}
    \end{flushleft}

    \begin{flushleft}
        \small
        ФАКУЛЬТЕТ
        \underline{<<Информатика и системы управления>>\ \ \ \ \ \ \ 
        \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ } \\
        КАФЕДРА
        \underline{<<Программное обеспечение ЭВМ и
        информационные технологии>>
        \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
    \end{flushleft}

    \vspace{4cm}

    \begin{center}
        \textbf{Лабораторная работа № 19} \\ 
        \hfill
        
        \textbf{Обработка списков на Prolog} \\
        \vspace{0.5cm}
        \textbf{} \\
    \end{center}

    \vspace{4cm}

    \begin{flushleft}
        \begin{tabular}{ll}
            \textbf{Дисциплина} & Функциональное и логическое программирование \\
            \textbf{Студент} & Сиденко А.Г. \\
            \textbf{Группа} & ИУ7-63Б \\
            \textbf{Преподаватель} & Толпинская Н.Б., Строганов Ю.В.  \\
        \end{tabular}
    \end{flushleft}

    \vspace{4cm}

   \begin{center}
        Москва, 2020 г.
    \end{center}

\end{titlepage}

\textbf{Задание}

Используя хвостовую рекурсию, разработать эффективную программу, позволяющую:
\begin{enumerate}
\item Найти длину списка (по верхнему уровню);
\item Найти сумму элементов числового списка 
\item Найти сумму элементов числового списка, стоящих на нечетных позициях исходного списка (нумерация от 0) 
\end{enumerate}

Убедиться в правильности результатов. 

Для одного из вариантов вопроса и одного из заданий составить таблицу, отражающую конкретный порядок работы системы. 


\hfill

\textbf{Программа}

\begin{lstlisting}
domains  list = integer*  length, summa = integerpredicates  length(list, length).  sum(list, summa).  odd_sum(list, summa).clauses  length([], 0):-!.  length([_|Tail], Length):-    length(Tail, TailLength),    Length = TailLength + 1.      sum([], 0):-!.  sum([Head|Tail], Sum):-    sum(Tail, TailSum),    Sum = TailSum + Head.      odd_sum([], 0):-!.  odd_sum([_], 0):-!.  odd_sum([_, Second|Tail], Sum):-    odd_sum(Tail, TailSum),    Sum = TailSum + Second.
\end{lstlisting}

\textbf{Приведем таблицу для нахождения длины. }
\begin{lstlisting}
goal  length([1,2,4], Length).
\end{lstlisting}

\begin{longtable}{|p{0.5cm}|p{5cm}|p{6cm}|p{5.5cm}|}
	\hline
 	№ шага & Состояние резольвенты & Сравниваемые термы; результат; подстановка, если есть  & Дальнейшие действия: прямой ход или откат \\ \hline
	1 & length([1,2,4], Length) & По length([1,2,4], Length) ищется системой определение отношения (по имени предиката и списку (числу) аргументов) & Определение отношения найдено, заносится в стек length([1,2,4], Length), прямой ход \\ \hline
	
	2 &length([2,4], TailLength), Length = TailLength + 1 & Начинает <<раскрываться>> правило, т.е. доказывается каждое целевое утверждение в теле правила последовательно слева направо
	length([2,4], TailLength), Length = TailLength + 1 & Прямой ход\\ \hline
	
	3 & length([2,4], TailLength), Length = TailLength + 1 & По length([2,4], Length) ищется системой определение отношения (по имени предиката и списку (числу) аргументов) & Определение отношения найдено, заносится в стек length([2,4], Length), прямой ход \\ \hline
	
	4 &length([4], TailLength), Length = TailLength + 1, Length = TailLength + 1 & Начинает <<раскрываться>> правило, т.е. доказывается каждое целевое утверждение в теле правила последовательно слева направо
	length([4], TailLength), Length = TailLength + 1 & Прямой ход\\ \hline

	5 & length([4], TailLength), Length = TailLength + 1, Length = TailLength + 1 & По length([4], Length) ищется системой определение отношения (по имени предиката и списку (числу) аргументов) & Определение отношения найдено, заносится в стек length([4], Length), прямой ход \\ \hline
	
	6 &length([], TailLength), Length = TailLength + 1, Length = TailLength + 1, Length = TailLength + 1 & Начинает <<раскрываться>> правило, т.е. доказывается каждое целевое утверждение в теле правила последовательно слева направо
	length([], TailLength), Length = TailLength + 1 & Прямой ход\\ \hline
	
	7 & length([], TailLength), Length = TailLength + 1, Length = TailLength + 1, Length = TailLength + 1 & По length([], Length) ищется системой определение отношения (по имени предиката и списку (числу) аргументов) & Определение отношения найдено, заносится в стек length([], Length), прямой ход \\ \hline
	
	8 & Length = 0 + 1, Length = TailLength + 1, Length = TailLength + 1 & TailLength=0 & Успех, достаем из стека length([], Length).  Отсечение, больше определения отношения не ищется, переход к следующему целевому утверждению \\ \hline
	
	9 & Length = 1 + 1, Length = TailLength + 1 & TailLength=1 & Успех, достаем из стека length([4], Length). Больше определений с таким именем нет, переход к следующему целевому утверждению \\ \hline
	
	10 & Length = 2 + 1 & TailLength=2 & Успех, достаем из стека length([2,4], Length). Больше определений с таким именем нет, переход к следующему целевому утверждению \\ \hline
	
	11 & Резольента пуста & Length=3 & Успех, достаем из стека length([1,2,4], Length). Больше определений с таким именем нет, резольента пуста. Вывод результата. Стек пуст, завершение программы \\ \hline
	
\end{longtable}

\hfill

\textbf{Ответы на вопросы}

\begin{enumerate} 

\item Что такое рекурсия? Как организуется хвостовая рекурсия в Prolog? Как организовать выход из рекурсии в Prolog?

Рекурсия позволяет использовать в процессе определения предиката его самого. 

Хвостовая рекурсия: Для ее осуществления рекурсивный вызов определяемого предиката должен быть последней подцелью в теле рекурсивного правила и к моменту рекурсивного вызова не должно остаться точек возврата (непроверенных альтернатив). 

Параметры должны изменяться на каждом шаге так, чтобы в итоге либо сработал базис рекурсии, либо условие выхода из рекурсии, размещенное в самом правиле.

\item Какое первое состояние резольвенты?

Вопрос. 

\item В каких пределах программы уникальны переменные? 

Областью действия переменной в Прологе является одно предложение. В разных предложениях может использоваться одно имя переменной для обозначения разных объектов. Исключением является анонимная переменная. Каждая анонимная переменная -- это отдельный объект.

\item В какой момент, и каким способом системе удается получить доступ к голове списка?

В Prolog существует более общий способ доступа к элементам списка. Для этого используется метод разбиения списка на начало и остаток. Для этого используется вертикальная черта (|) за последним элементом начала. 

Если начало состоит из одного элемента, то получим: голову и хвост

\item Каково назначение использования алгоритма унификации? Каков результат работы алгоритма унификации? 

Пролог выполняет унификацию в двух случаях: когда цель сопоставляется с заголовком предложения или когда используется знак равенства, который является инфиксным предикатом (предикатом, который расположен между своими аргументами, а не перед ними).

Унификация двух термов -- это основной шаг доказательства. В процессе работы система выполняет большое число унификаций.
\textbf{Унификация} -- операция, которая позволяет формализовать процесс логического вывода. 

\item Каков результат работы алгоритма унификации?

Унификация представляет собой процесс сопоставления цели с фактами и правилами базы знаний. Цель может быть согласована, если она может быть сопоставлена с заголовком какого-либо предложения базы.

Результатом его работы является последняя из построенных подстановок. 

\item Как формируется новое состояние резольвенты?

Резольвента - текущая цель, существующая на любой стадии вычислений. Резольвенты порождаются целью и каким-либо правилом или фактом, которые просматриваются последовательно сверху вниз. Если резольвента существует при наиболее общей унификации, она вычисляется. Если пустая резольвента с помощью такой стратегии не найдена, то ответ на вопрос отрицателен.

\item Как применяется подстановка, полученная с помощью алгоритма унификации?

При согласовании переменные получают значения, указанные с другой стороны от знака <<=>>, если переменные еще не были связаны. Переменные становятся связанными и после успешного согласования всех целевых утверждений, будет напечатано значение связанных переменных.

\item В каких случаях запускается механизм отката?

Откат дает возможность получить много решений в одном вопросе к программе. 

Во всех точках программы, где существуют альтернативы, в стек заносятся точки возврата. 

Если впоследствии окажется, что выбранный вариант не приводит к успеху, то осуществляется откат к последней из имеющихся в стеке точек программы, где был выбран один из альтернативных вариантов. 

Выбирается очередной вариант, программа продолжает свою работу. Если все варианты в точке уже были использованы, то регистрируется неудачное завершение и осуществляется переход на предыдущую точку возврата, если такая есть. 

При откате все связанные переменные, которые были означены после этой точки, опять освобождаются.

\item Когда останавливается работа системы? Как это определяется на формальном уровне?

Когда стек пуст. 

\end{enumerate}
 
\end{document}